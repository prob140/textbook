---
redirect_from:
  - "/chapter-11/04-markov-chain-monte-carlo"
interact_link: content/Chapter_11/04_Markov_Chain_Monte_Carlo.ipynb
kernel_name: python3
kernel_path: content/Chapter_11
has_widgets: false
title: |-
  Markov Chain Monte Carlo
pagenum: 57
prev_page:
  url: /Chapter_11/03_Code_Breaking.html
next_page:
  url: /Chapter_11/05_Review_Conditioning_and_MC.html
suffix: .ipynb
search: j pi chain p q distribution algorithm r state mathbb n move x irreducible create transition detailed balance new markov probability set frac coin decoder large xn stationary matrix equations proposal lands decoders likelihood case example might suppose want going aperiodic space involves therefore metropolis proposed any according heads symmetry text monte carlo goal mcmc generate high dont constant called finite should desired its values solved hand only ratios even version here starts symmetric states transitions define acceptance ratio ge chance starting moves where say because stay steady says same works well equation decide next likelihoods current provides idea random

comment: "***PROGRAMMATICALLY GENERATED, DO NOT EDIT. SEE ORIGINAL FILES IN /content***"
---

    <main class="jupyter-page">
    <div id="page-info"><div id="page-title">Markov Chain Monte Carlo</div>
</div>
    
<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Markov-Chain-Monte-Carlo">Markov Chain Monte Carlo<a class="anchor-link" href="#Markov-Chain-Monte-Carlo"> </a></h2>
</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The goal of Markov Chain Monte Carlo (MCMC) is to generate random samples from complicated high dimensional distributions about which we have incomplete information. For example, it might be that we don't know the normalizing constant of the distribution, as we saw in the code breaking example of the previous section.</p>
<p>Suppose the distribution from which we want to generate a sample is called $\pi$. We are going to assume that $\pi$ is a probability distribution on a finite set, and you should imagine the set to be large. MCMC relies on a few observations.</p>
<ul>
<li><p>Let $X_0, X_1, \ldots $ be an irreducible aperiodic Markov Chain on a finite state space. Then the distribution of $X_n$ converges to a stationary distribution as $n$ gets large. If we can create a Markov Chain $\{X_n\}$ that has the desired distribution $\pi$ as its stationary distribution, then we can simulate draws from $\pi$ (or close enough to it) by running the chain for a long time and using the values $X_n$ for large $n$.</p>
</li>
<li><p>To create a transition matrix that results in $\pi$ as the stationary distribution, the easiest way is to try to ensure that the detailed balance equations are solved.</p>
</li>
<li><p>The detailed balance equations are equivalent to</p>
</li>
</ul>
$$
\frac{\pi(j)}{\pi(i)} ~ = ~  \frac{P(i, j)}{P(j, i)}, ~~ i \ne j
$$<p>The right hand side only involves the transition probabilities of the chain that we want to create. The left hand side only involves ratios of the terms in $\pi$, and therefore can be checked even if we don't know the constant that normalizes $\pi$.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Metropolis-Algorithm">Metropolis Algorithm<a class="anchor-link" href="#Metropolis-Algorithm"> </a></h3><p>Exactly who proposed the first algorithm to create such a Markov Chain is the subject of some debate. A general version was proposed by Hastings. Here we will describe an earlier version attributed to Metropolis and co-authors in 1953.</p>
<p>The goal is to create a transition matrix $\mathbb{P}$ so that $\pi$ and $\mathbb{P}$ together solve the detailed balance equations.</p>
<p>The algorithm starts with any symmetric, irreducible transition matrix $\mathbb{Q}$ on the state space. For example, if the state space is numerical you could start with, "Wherever the chain is, it picks one of the three closest values (including itself) with probability $1/3$ each." For a pair of states $i$ and $j$, the transition probability $Q(i, j)$ is called the <em>proposal probability</em>.</p>
<p>The algorithm then introduces additional randomization to create a new chain that is irreducible and aperiodic and has $\pi$ as its stationary distribution.</p>
<p>Here are the rules that determine the transitions of the new chain.</p>
<ul>
<li><p>Suppose the chain is at $i$ at time $n$, that is, suppose $X_n = i$. Pick a state $j$ according to the proposal probability $Q(i, j)$. This $j$ is the candidate state to which your chain might move.</p>
</li>
<li><p>Define the <em>acceptance ratio</em></p>
</li>
</ul>
$$
r(i, j) = \frac{\pi(j)}{\pi(i)}
$$<ul>
<li><p>If $r(i, j) \ge 1$, set $X_{n+1} = j$.</p>
</li>
<li><p>If $r(i, j) &lt; 1$, toss a coin that lands heads with chance $r(i, j)$.</p>
<ul>
<li>If the coin lands heads, set $X_{n+1} = j$. </li>
<li>If the coin lands tails, set $X_{n+1} = i$.</li>
</ul>
</li>
<li>Repeat all the steps, with $X_{n+1}$ as the starting value.</li>
</ul>
<p>Thus the new chain either moves to the state picked according to $\mathbb{Q}$, or it stays where it is. We say that it <em>accepts a move to a new state</em> based on $\mathbb{Q}$ and $r$, and otherwise it doesn't move.</p>
<p>The new chain is irreducible because the proposal chain is irreducible. It is aperiodic because it can stay in place. So it has a steady state distribution.</p>
<p>The alogrithm says that this steady state distribution is the same as the distribution $\pi$ that was used to define the ratios $r(i, j)$.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="How-to-Think-About-the-Algorithm">How to Think About the Algorithm<a class="anchor-link" href="#How-to-Think-About-the-Algorithm"> </a></h3><p>Before we prove that the algorithm works, let's examine what it is doing in the context of decoders.</p>
<p>First notice that we are requiring $\mathbb{Q}$ to be symmetric as well as irreducible. The symmetry requirement makes sense as each detailed balance equation involves transitions $i \to j$ as well as $j \to i$.</p>
<p>Fix any starting decoder and call it $i$. Now you have to decide where the chain is going to move next, that is, what the next decoder is going to be. The algorithm starts this process off by picking a decoder $j$ according to $\mathbb{Q}$. We say that <em>$\mathbb{Q}$ proposes a move to $j$</em>.</p>
<p>To decide whether or not the chain should move to $j$, remember that the distribution $\pi$ contains the likelihoods of all the decoders. You want to end up with decoders that have high likelihood, so it is natural to compare $\pi(i)$ and $\pi(j)$.</p>
<p>The algorithm does this by comparing the <em>acceptance ratio</em> $r(i, j) = \pi(j)/\pi(i)$ to 1.</p>
<ul>
<li><p>If $r(i, j) \ge 1$, the likelihood of $j$ is at least as large that of $i$, so you <em>accept the proposal</em> and move to $j$.</p>
</li>
<li><p>If $r(i, j) &lt; 1$, the proposed decoder $j$ has <em>less</em> likelihood than the current $i$, so it is tempting to stay at $i$. But this risks the chain getting stuck at a local maximum. The algorithm provides a chance to avoid this, by tossing a biased coin. If the coin lands heads, the chain moves to $j$ even though $j$ has a <em>lower</em> likelihood than the current decoder $i$. The idea is that from this new position there might be paths to decoders that have the highest likelihoods of all.</p>
</li>
</ul>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="The-Algorithm-Works">The Algorithm Works<a class="anchor-link" href="#The-Algorithm-Works"> </a></h3><p>We will now show that the detailed balance equations are solved by the desired limit distribution $\pi$ and the transition matrix $\mathbb{P}$ of the chain created by the Metropolis algorithm.</p>
<p>Take any two distinct states $i$ and $j$.</p>
<h4 id="Case-1:-$\pi(i)-=-\pi(j)$">Case 1: $\pi(i) = \pi(j)$<a class="anchor-link" href="#Case-1:-$\pi(i)-=-\pi(j)$"> </a></h4><p>Then $r(i, j) = 1$. By the algorithm, $P(i, j) = Q(i, j)$ and also $P(j, i) = Q(j, i) = Q(i, j)$ by the symmetry of $Q$.</p>
<p>Therefore $P(i, j) = P(j, i)$ and the detailed balance equation $\pi(i)P(i, j) = \pi(j)P(j, i)$ is satisfied.</p>
<h4 id="Case-2:-$\pi(j)-&lt;-\pi(i)$">Case 2: $\pi(j) &lt; \pi(i)$<a class="anchor-link" href="#Case-2:-$\pi(j)-&lt;-\pi(i)$"> </a></h4><p>Then $r(i, j) &lt; 1$, so</p>
$$
P(i, j) ~=~ Q(i, j)r(i, j) 
~=~ Q(j, i)\frac{\pi(j)}{\pi(i)} ~~~~ \text{ by the symmetry of } Q \text{ and definition of }r 
$$<p>Now $r(j, i) &gt; 1$, so the algorithm says $P(j, i) = Q(j, i)$.</p>
<p>Therefore</p>
$$
P(i, j) ~ = ~ P(j, i)\frac{\pi(j)}{\pi(i)}
$$<p>which is the same as</p>
$$
\pi(i)P(i, j) ~ = ~ \pi(j)P(j, i)
$$<h4 id="Case-2:-$\pi(j)-&gt;-\pi(i)$">Case 2: $\pi(j) &gt; \pi(i)$<a class="anchor-link" href="#Case-2:-$\pi(j)-&gt;-\pi(i)$"> </a></h4><p>Reverse the roles of $i$ and $j$ in Case 2.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>That's it! A simple and brilliant idea that provides a solution to a difficult problem. In lab, you will see it in action when you implement the algorithm to decode text.</p>

</div>
</div>
</div>
</div>

 


    </main>
    